@name HAX
@inputs Key
@inputs EGP:wirelink
@outputs 
@persist Lines:array
@persist CurrentLine NextLineChar
@persist FontSize
@persist LastKey
@trigger 

if (first())
{
    setName("GUI in Visual Basic\nto backtrace the killer's IP address")
    
    Lines = array()
    Lines:pushString("struct group_info init_groups = { .usage = ATOMIC_INIT(2) };")
    Lines:pushString("struct group_info *groups_alloc(int gidsetsize){")
    Lines:pushString("    struct group_info *group_info;")
    Lines:pushString("    int nblocks;")
    Lines:pushString("    int i;")
    Lines:pushString("")
    Lines:pushString("    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;")
    Lines:pushString("    /* Make sure we always allocate at least one indirect block pointer */")
    Lines:pushString("    nblocks = nblocks ? : 1;")
    Lines:pushString("    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);")
    Lines:pushString("    if (!group_info)")
    Lines:pushString("        return NULL;")
    Lines:pushString("    group_info->ngroups = gidsetsize;")
    Lines:pushString("    group_info->nblocks = nblocks;")
    Lines:pushString("    atomic_set(&group_info->usage, 1);")
    Lines:pushString("")
    Lines:pushString("    if (gidsetsize <= NGROUPS_SMALL)")
    Lines:pushString("        group_info->blocks[0] = group_info->small_block;")
    Lines:pushString("    else {")
    Lines:pushString("        for (i = 0; i < nblocks; i++) {")
    Lines:pushString("            gid_t *b;")
    Lines:pushString("            b = (void *)__get_free_page(GFP_USER);")
    Lines:pushString("            if (!b)")
    Lines:pushString("                goto out_undo_partial_alloc;")
    Lines:pushString("            group_info->blocks[i] = b;")
    Lines:pushString("        }")
    Lines:pushString("    }")
    Lines:pushString("    return group_info;")
    Lines:pushString("")
    Lines:pushString("out_undo_partial_alloc:")
    Lines:pushString("    while (--i >= 0) {")
    Lines:pushString("        free_page((unsigned long)group_info->blocks[i]);")
    Lines:pushString("    }")
    Lines:pushString("    kfree(group_info);")
    Lines:pushString("    return NULL;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("EXPORT_SYMBOL(groups_alloc);")
    Lines:pushString("")
    Lines:pushString("void groups_free(struct group_info *group_info)")
    Lines:pushString("{")
    Lines:pushString("    if (group_info->blocks[0] != group_info->small_block) {")
    Lines:pushString("        int i;")
    Lines:pushString("        for (i = 0; i < group_info->nblocks; i++)")
    Lines:pushString("            free_page((unsigned long)group_info->blocks[i]);")
    Lines:pushString("    }")
    Lines:pushString("    kfree(group_info);")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("EXPORT_SYMBOL(groups_free);")
    Lines:pushString("")
    Lines:pushString("/* export the group_info to a user-space array */")
    Lines:pushString("static int groups_to_user(gid_t __user *grouplist,")
    Lines:pushString("              const struct group_info *group_info)")
    Lines:pushString("{")
    Lines:pushString("    int i;")
    Lines:pushString("    unsigned int count = group_info->ngroups;")
    Lines:pushString("")
    Lines:pushString("    for (i = 0; i < group_info->nblocks; i++) {")
    Lines:pushString("        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);")
    Lines:pushString("        unsigned int len = cp_count * sizeof(*grouplist);")
    Lines:pushString("")
    Lines:pushString("        if (copy_to_user(grouplist, group_info->blocks[i], len))")
    Lines:pushString("            return -EFAULT;")
    Lines:pushString("")
    Lines:pushString("        grouplist += NGROUPS_PER_BLOCK;")
    Lines:pushString("        count -= cp_count;")
    Lines:pushString("    }")
    Lines:pushString("    return 0;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("/* fill a group_info from a user-space array - it must be allocated already */")
    Lines:pushString("static int groups_from_user(struct group_info *group_info,")
    Lines:pushString("    gid_t __user *grouplist)")
    Lines:pushString("{")
    Lines:pushString("    int i;")
    Lines:pushString("    unsigned int count = group_info->ngroups;")
    Lines:pushString("")
    Lines:pushString("    for (i = 0; i < group_info->nblocks; i++) {")
    Lines:pushString("        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);")
    Lines:pushString("        unsigned int len = cp_count * sizeof(*grouplist);")
    Lines:pushString("")
    Lines:pushString("        if (copy_from_user(group_info->blocks[i], grouplist, len))")
    Lines:pushString("            return -EFAULT;")
    Lines:pushString("")
    Lines:pushString("        grouplist += NGROUPS_PER_BLOCK;")
    Lines:pushString("        count -= cp_count;")
    Lines:pushString("    }")
    Lines:pushString("    return 0;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("/* a simple Shell sort */")
    Lines:pushString("static void groups_sort(struct group_info *group_info)")
    Lines:pushString("{")
    Lines:pushString("    int base, max, stride;")
    Lines:pushString("    int gidsetsize = group_info->ngroups;")
    Lines:pushString("")
    Lines:pushString("    for (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)")
    Lines:pushString("        ; /* nothing */")
    Lines:pushString("    stride /= 3;")
    Lines:pushString("")
    Lines:pushString("    while (stride) {")
    Lines:pushString("        max = gidsetsize - stride;")
    Lines:pushString("        for (base = 0; base < max; base++) {")
    Lines:pushString("            int left = base;")
    Lines:pushString("            int right = left + stride;")
    Lines:pushString("            gid_t tmp = GROUP_AT(group_info, right);")
    Lines:pushString("")
    Lines:pushString("            while (left >= 0 && GROUP_AT(group_info, left) > tmp) {")
    Lines:pushString("                GROUP_AT(group_info, right) =")
    Lines:pushString("                    GROUP_AT(group_info, left);")
    Lines:pushString("                right = left;")
    Lines:pushString("                left -= stride;")
    Lines:pushString("            }")
    Lines:pushString("            GROUP_AT(group_info, right) = tmp;")
    Lines:pushString("        }")
    Lines:pushString("        stride /= 3;")
    Lines:pushString("    }")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("/* a simple bsearch */")
    Lines:pushString("int groups_search(const struct group_info *group_info, gid_t grp)")
    Lines:pushString("{")
    Lines:pushString("    unsigned int left, right;")
    Lines:pushString("")
    Lines:pushString("    if (!group_info)")
    Lines:pushString("        return 0;")
    Lines:pushString("")
    Lines:pushString("    left = 0;")
    Lines:pushString("    right = group_info->ngroups;")
    Lines:pushString("    while (left < right) {")
    Lines:pushString("        unsigned int mid = (left+right)/2;")
    Lines:pushString("        if (grp > GROUP_AT(group_info, mid))")
    Lines:pushString("            left = mid + 1;")
    Lines:pushString("        else if (grp < GROUP_AT(group_info, mid))")
    Lines:pushString("            right = mid;")
    Lines:pushString("        else")
    Lines:pushString("            return 1;")
    Lines:pushString("    }")
    Lines:pushString("    return 0;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("/**")
    Lines:pushString(" * set_groups - Change a group subscription in a set of credentials")
    Lines:pushString(" * @new: The newly prepared set of credentials to alter")
    Lines:pushString(" * @group_info: The group list to install")
    Lines:pushString(" *")
    Lines:pushString(" * Validate a group subscription and, if valid, insert it into a set")
    Lines:pushString(" * of credentials.")
    Lines:pushString(" */")
    Lines:pushString("int set_groups(struct cred *new, struct group_info *group_info)")
    Lines:pushString("{")
    Lines:pushString("    put_group_info(new->group_info);")
    Lines:pushString("    groups_sort(group_info);")
    Lines:pushString("    get_group_info(group_info);")
    Lines:pushString("    new->group_info = group_info;")
    Lines:pushString("    return 0;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("EXPORT_SYMBOL(set_groups);")
    Lines:pushString("")
    Lines:pushString("/**")
    Lines:pushString(" * set_current_groups - Change current's group subscription")
    Lines:pushString(" * @group_info: The group list to impose")
    Lines:pushString(" *")
    Lines:pushString(" * Validate a group subscription and, if valid, impose it upon current's task")
    Lines:pushString(" * security record.")
    Lines:pushString(" */")
    Lines:pushString("int set_current_groups(struct group_info *group_info)")
    Lines:pushString("{")
    Lines:pushString("    struct cred *new;")
    Lines:pushString("    int ret;")
    Lines:pushString("")
    Lines:pushString("    new = prepare_creds();")
    Lines:pushString("    if (!new)")
    Lines:pushString("        return -ENOMEM;")
    Lines:pushString("")
    Lines:pushString("    ret = set_groups(new, group_info);")
    Lines:pushString("    if (ret < 0) {")
    Lines:pushString("        abort_creds(new);")
    Lines:pushString("        return ret;")
    Lines:pushString("    }")
    Lines:pushString("")
    Lines:pushString("    return commit_creds(new);")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("EXPORT_SYMBOL(set_current_groups);")
    Lines:pushString("")
    Lines:pushString("SYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)")
    Lines:pushString("{")
    Lines:pushString("    const struct cred *cred = current_cred();")
    Lines:pushString("    int i;")
    Lines:pushString("")
    Lines:pushString("    if (gidsetsize < 0)")
    Lines:pushString("        return -EINVAL;")
    Lines:pushString("")
    Lines:pushString("    /* no need to grab task_lock here; it cannot change */")
    Lines:pushString("    i = cred->group_info->ngroups;")
    Lines:pushString("    if (gidsetsize) {")
    Lines:pushString("        if (i > gidsetsize) {")
    Lines:pushString("            i = -EINVAL;")
    Lines:pushString("            goto out;")
    Lines:pushString("        }")
    Lines:pushString("        if (groups_to_user(grouplist, cred->group_info)) {")
    Lines:pushString("            i = -EFAULT;")
    Lines:pushString("            goto out;")
    Lines:pushString("        }")
    Lines:pushString("    }")
    Lines:pushString("out:")
    Lines:pushString("    return i;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("/*")
    Lines:pushString(" *    SMP: Our groups are copy-on-write. We can set them safely")
    Lines:pushString(" *    without another task interfering.")
    Lines:pushString(" */")
    Lines:pushString("")
    Lines:pushString("SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)")
    Lines:pushString("{")
    Lines:pushString("    struct group_info *group_info;")
    Lines:pushString("    int retval;")
    Lines:pushString("")
    Lines:pushString("    if (!nsown_capable(CAP_SETGID))")
    Lines:pushString("        return -EPERM;")
    Lines:pushString("    if ((unsigned)gidsetsize > NGROUPS_MAX)")
    Lines:pushString("        return -EINVAL;")
    Lines:pushString("")
    Lines:pushString("    group_info = groups_alloc(gidsetsize);")
    Lines:pushString("    if (!group_info)")
    Lines:pushString("        return -ENOMEM;")
    Lines:pushString("    retval = groups_from_user(group_info, grouplist);")
    Lines:pushString("    if (retval) {")
    Lines:pushString("        put_group_info(group_info);")
    Lines:pushString("        return retval;")
    Lines:pushString("    }")
    Lines:pushString("")
    Lines:pushString("    retval = set_current_groups(group_info);")
    Lines:pushString("    put_group_info(group_info);")
    Lines:pushString("")
    Lines:pushString("    return retval;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("/*")
    Lines:pushString(" * Check whether we're fsgid/egid or in the supplemental group..")
    Lines:pushString(" */")
    Lines:pushString("int in_group_p(gid_t grp)")
    Lines:pushString("{")
    Lines:pushString("    const struct cred *cred = current_cred();")
    Lines:pushString("    int retval = 1;")
    Lines:pushString("")
    Lines:pushString("    if (grp != cred->fsgid)")
    Lines:pushString("        retval = groups_search(cred->group_info, grp);")
    Lines:pushString("    return retval;")
    Lines:pushString("}")
    Lines:pushString("")
    Lines:pushString("EXPORT_SYMBOL(in_group_p);")
    Lines:pushString("")
    Lines:pushString("int in_egroup_p(gid_t grp)")
    Lines:pushString("{")
    Lines:pushString("    const struct cred *cred = current_cred();")
    Lines:pushString("    int retval = 1;")
    Lines:pushString("")
    Lines:pushString("    if (grp != cred->egid)")
    Lines:pushString("        retval = groups_search(cred->group_info, grp);")
    Lines:pushString("    return retval;")
    Lines:pushString("}")
    Lines:pushString("")

    CurrentLine = 1
    NextLineChar = 1
    
    EGP:egpClear()
    
    FontSize = 12
}

if (Key != LastKey & Key != 0)
{
    CharsToWrite = randint(2, 5)
    for (I = 1, CharsToWrite)
    {
        if (NextLineChar == 1)
        {
            # insert new line
            EGP:egpText(CurrentLine, "", vec2(8, FontSize * (CurrentLine - 1)))
            EGP:egpFont(CurrentLine, "Courier New", FontSize)
            EGP:egpColor(CurrentLine, vec4(0, 255, 0, 255))
        }
        NextLineChar++
        
        Line = Lines[CurrentLine, string]
        if (NextLineChar > Line:length())
        {
            # go on to the next line
            CurrentLine++
            NextLineChar = 1
        }
        else
        {
            # insert chars
            EGP:egpSetText(CurrentLine, Line:sub(1, NextLineChar))
        }
    }
}

LastKey = Key
